<html>
<head>
    <style>

    * {
      font-family: 'Montserrat', sans-serif
    }

    body {
      background-color: #1d1d1d;
    }

    #pm {
      border: 0;
      width: 100%;
      height: 75%;
    }

    #controls {
      display: grid;
      grid-template-columns: 0.3fr 3fr;
      grid-gap: 0.5em;
      height: 20%;
      padding: 0.5em;
    }

    #buttons {
      display: grid;
      grid-gap: 0.5em;
    }

    #buttons button {
      font-size: inherit;
      background-color: #343434;
      color: white;
      transition: background-color 0.1s linear;
      border: none;
      border-radius: 10px;
      padding: 0.45em 0.35em;
      cursor: pointer;
    }

    #buttons button:hover {
      background-color: #4a4a4a
    }

    .io-container textarea {
      width: 100%;
      height: 100%;

      font-family: monospace;
      padding: 0.5em;
      border: none;
      resize: none;
      color: white;
      background-color: #343434;
      overflow: auto;
      white-space: pre;
    }

    .io-container {
        display: flex;
        flex-direction: column;
        background-color: white;
    }

    .io-container div {
      color: white;
    }

    </style>
</head>
<body>
    <script src="gantt_generator.js"></script>
    <script src="./mermaid.min.js"></script>
    <script defer>
        mermaid.initialize({ startOnLoad: true });
        async function renderMermaid(graphDefinition) {
          const id = 'mermaid-' + Date.now();

          const { svg } = await mermaid.render(id, graphDefinition);

          return svg;
        }
        let defaultSpecification;

        // Pipeline Manager communication

        let PM;
        window.addEventListener('load', () => {
          PM = document.getElementById('pm');
          sendPM({ method: 'register_external_frontend' });
          fetch('./gantt-specification.json')
          .then((response) => response.json())
          .then((data) => {
              console.log('Default specification loaded.');
              defaultSpecification = data;
              sendPM({ method: "specification_change", params: { specification: defaultSpecification } });
            });
        });
        let id_ = 0;
        const sendPM = (data) => PM.contentWindow.postMessage(data);
        const createJSONRPCResponse = (id, response) => ({ jsonrpc: "2.0", id, result: response });

        let latestGraphRequest;
        let isLastGraphRequestMadeByUser = false;
        let lastGraph;

        window.addEventListener('message', (event) => {
          const data = event.data;
          if (data.method !== undefined) {
            const response = handleExternalRequest(data);
            sendPM(createJSONRPCResponse(data.id, response));
          } else {
            const target = document.getElementById('frontend-endpoint-responses');
            if (data.id === latestGraphRequest) {
              try {
                const mermaidMD = generateGanttChart(data.result.dataflow.graphs[0]);
                if (mermaidMD !== lastGraph) {
                  lastGraph = mermaidMD;
                  renderMermaid(mermaidMD).then((svg) => {
                    target.innerHTML = svg;
                  });
                }
              } catch (error) {
                if (isLastGraphRequestMadeByUser) {
                  sendPM({ method: 'notification_send', params: { type: 'error', title: error.message, details: error.message } });
                }
              }
            }
          }
        });

        // Frontend requests

        const getInput = () => JSON.parse(document.getElementById('input').value);

        const graph_get = () => {
          latestGraphRequest = id_++;
          sendPM({ id: latestGraphRequest, method: 'graph_get' })
          isLastGraphRequestMadeByUser = true;
        };

        // Graph export functions

        const export_graph_svg = () => {
          const svgElement = document.querySelector('#frontend-endpoint-responses svg');
          if (!svgElement) {
            alert('The graph is not available to export. Generate the graph first.');
            return;
          }
          const serializer = new XMLSerializer();
          const svgString = serializer.serializeToString(svgElement);
          const blob = new Blob([svgString], { type: 'image/svg+xml' });
          const url = URL.createObjectURL(blob);

          const a = document.createElement('a');
          a.href = url;
          a.download = 'gantt_chart.svg';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        };

        const export_graph_png = () => {
          const svgElement = document.querySelector('#frontend-endpoint-responses svg');
          if (!svgElement) {
            alert('The graph is not available to export. Generate the graph first.');
            return;
          }

          try {
            // Get dimensions - prefer viewBox, then explicit attributes, then computed size
            let width, height;
            const viewBox = svgElement.getAttribute('viewBox');

            if (viewBox) {
              const viewBoxValues = viewBox.split(/[\s,]+/).map(parseFloat);
              width = viewBoxValues[2];
              height = viewBoxValues[3];
            } else {
              // Get the actual rendered size
              const rect = svgElement.getBoundingClientRect();
              width = rect.width;
              height = rect.height;
            }

            // Fallback if dimensions are still invalid
            if (!width || !height || width <= 0 || height <= 0) {
              const bbox = svgElement.getBBox();
              width = bbox.width || 800;
              height = bbox.height || 600;
            }

            width = parseFloat(width) || 800;
            height = parseFloat(height) || 600;

            // Create canvas
            const scale = 2;
            const canvas = document.createElement('canvas');
            canvas.width = width * scale;
            canvas.height = height * scale;
            const ctx = canvas.getContext('2d');

            // Fill white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Scale context for high DPI
            ctx.scale(scale, scale);

            // Create image from SVG
            const svgString = new XMLSerializer().serializeToString(svgElement);
            const img = new Image();

            img.onload = function() {
              // Draw at full size
              ctx.drawImage(img, 0, 0, width, height);
              canvas.toBlob(function(blob) {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'gantt_chart.png';
                link.click();
                URL.revokeObjectURL(link.href);
              });
            };

            img.onerror = function() {
              alert('Error: Could not render SVG to image.');
              console.error('Image load failed');
            };

            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            img.src = URL.createObjectURL(blob);
          } catch (error) {
            alert('Error exporting PNG: ' + error.message);
            console.error(error);
          }
        };

        // External requests

        const handleExternalRequest = (request) => {
          const { method } = request;

          let response;
          switch (method) {
            case 'specification_get':
              response = { type: 0, content: defaultSpecification };
              break;
            case 'app_capabilities':
              response = {};
              break
            case 'frontend_on_connect':
              console.log('Connected to external application frontend.');
              response = null;
              break
            case 'dataflow_run':
              break
            case 'dataflow_import':
              const { params: { external_application_dataflow } } = request;
              response = { type: 0, content: JSON.parse(external_application_dataflow) }
              break
            case 'dataflow_export':
              const { params: { dataflow } } = request;
              response = { type: 0, content: dataflow, filename: 'pipeline.json' }
              break;
            default:
              response = null;
          }

          return response;
        };

        setInterval(() => {
          if (document.getElementById('autorefresh').checked) {
            graph_get();
            isLastGraphRequestMadeByUser = false;
          }
        }, 2000);
    </script>
    <div class="wrapper">
        <iframe id="pm" src="pipeline-manager"></iframe>
        <div>
            <div id="controls">
                <div id="buttons">
                  <button onclick="graph_get()">Generate graph</button>
                  <button onclick="export_graph_svg()">Download as SVG image</button>
                  <button onclick="export_graph_png()">Download as PNG image</button>
                  <label><input type="checkbox" id="autorefresh" /> Autorefresh</label>
                </div>
                <div class="io-container">
                  <div id="frontend-endpoint-responses">
                    <h2>No gantt generated</h2>
                  </div>
            </div>
        </div>
    </div>
</body>
</html>
